
<canvas id="canvas2" width="100" height="100" style="image-rendering: pixelated;"></canvas>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAS0lEQVQYGY2OwQ4AMARDddn///K2yggHwkXa1CucN/IHgARptu6VVCPGQTyIVrOS1dXsGKj+47FXk9YRNUhSR0vE6jfzvdqMao+DF5Z0Fw1RhhvUAAAAAElFTkSuQmCC" id="pattern0">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAARklEQVQYGY1OQQ4AIAjK5v+/XNFiw4MNLgriINbBeIiIIZTynbOwD7GNibgOesuuE595t6NtYzICUzupjr0YIbATdoUdvQEhmBAYdPdqYgAAAABJRU5ErkJggg==" id="pattern1">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAUklEQVQYGY2PAQoAIAgDVfz/l6tFCxWMhJCtc5aOVXJKVSVI2rtbUksAxqmVQKR1ic7pDuC9dUBcDcZpcJK69g3+pKbP1JSo72qYr/UJBNw9YwICrBwX6pBuOAAAAABJRU5ErkJggg==" id="pattern2">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAVUlEQVQYGYWPUQ4AIAhCs3X/K1e4cOm0+GkYPEvmVjsSkXZZjvUczm2DcBTKLpjRWETdVmckBkdGQYEB3vdIqby+ke0qhLl9hiuqsK0G9UXWIGg/4gInBSAVay240gAAAABJRU5ErkJggg==" id="pattern3">

<script>
/*
<img src="v2-1.png" id="pattern0">
<img src="v2-2.png" id="pattern1">
<img src="v2-3.png" id="pattern2">
<img src="v2-4.png" id="pattern3">
*/
    let usedColors = {}
    var canvas2 = document.getElementById('canvas2');
    var ctx2 = canvas2.getContext('2d');

    function indexToCoords(n) {
        let x = 10 * Math.floor(n % 10)
        let y = 10* (Math.floor(n / 10))
        return [x,y]
    }

    function setup() {
        var cells = [[], [], [], []]
        
        for (let n = 0; n<100; n++) {
            let x = Math.floor(Math.random() * 4)
            cells[x].push(n)
        }
        
        for (let n = 0; n<4; n++) {
            let image = document.getElementById("pattern" + n)
            image.addEventListener('load', e => {
                cells[n].forEach(index => {
                    let xy = indexToCoords(index)
                    ctx2.drawImage(image, xy[0], xy[1]);                  
                })
            })
        }
        setTimeout( () => {checkBorders()}, 1000)
        
    }

    function readImgd(x,y) {
        var canvas2 = document.getElementById('canvas2');
        var ctx2 = canvas2.getContext('2d');
        var imgd = ctx2.getImageData(x, y, 1, 1);
        return imgd
    }
    function readPixel(x, y) {
        let imgd = readImgd(x,y)
        return imgd.data
    }

    function outside(x,y) {
        if (x < 0) return true
        if (y < 0) return true
        if (x > 99) return true
        if (y > 99) return true
        
    }
    function startTrace(x, y) {
        if (outside(x,y)) {
            return
        }
        let pix = readPixel(x,y)
        
        if (!(pix[0] == 0 && pix[1] == 0 && pix[2] == 0)) {
                return //not black, do nothing
        }
        trace(x,y, unusedColorTripe())
    }
    function trace(x, y, color) {
        if (outside(x,y)) {
            return
        }
        
        let imgd = readImgd(x,y)
        let pix = imgd.data
        if (!(pix[0] == 0 && pix[1] == 0 && pix[2] == 0)) {
                return //not black, do nothing
            } else {
                let red = color[0]
                let green = color[1]
                let blue = color[2]
                pix[0] = red //make it red
                pix[2] = blue
                pix[1] = green
                ctx2.putImageData(imgd, x, y)
                trace(x-1, y, color)
                trace(x+1, y, color)
                trace(x, y-1, color)
                trace(x, y+1, color)

            }
    }

    function color() {
        let c =  Math.floor(Math.random() * 4) * 50 + 50
        return c
    }

    function colorTriple() {
        return [color(), color(), color()]
    }

    function unusedColorTripe() {
        let c = colorTriple()
        let s = c.toString()
        while (s in usedColors) {
            c = colorTriple()
            s = c.toString()
        }
        console.log("unused color returning " + c + " which tostring is " + s)
        usedColors[s] = true
        return c
    }

    function checkBorders() {
        for (let n = 0; n<100; n++) {
            startTrace(n, 0)
            startTrace(n, 99)
            startTrace(0, n)
            startTrace(99, n)
        }
        console.log("all used colors: ")
        console.log(usedColors)
        setTimeout(() => {fillBorderFigures(0)}, 1000)
        setTimeout(() => {fillBorderFigures(99)}, 5000)
    }

    function notWhite(p) {
        return p[0] != 255 || p[1] != 255 || p[2] != 255
    }

    function bucketFill(color, x, y) {
        if (outside(x,y)) {
            return
        }
        let imgd = readImgd(x,y)
        let pix = imgd.data
        if (notWhite(pix)) {
            return
        }
        pix[0] = color[0] 
        pix[1] = color[1]
        pix[2] = color[2]
        ctx2.putImageData(imgd, x, y)
        bucketFill(color, x-1, y)
        bucketFill(color, x+1, y)
        bucketFill(color, x, y-1)
        bucketFill(color, x, y+1)
    }

    function fillBorderFigures(y) {
        let figures = {}
            for (let x = 0; x<100; x++) {
                let imgd = readImgd(x,y)
                let pix = imgd.data
                if (notWhite(pix)) {
                    //found start or end of a figure
                    rgb = [pix[0], pix[1], pix[2]]
                    let s = rgb.toString() //string representation for dict entry
                    if (s in figures) { //already found the same color on this border: fill 
                        bucketFill(rgb, x-1, y)
                    } else { //mark as found
                        figures[s] = true
                    }
                }
            }
    }
    setup()
</script>
